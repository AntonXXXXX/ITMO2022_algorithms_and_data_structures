#### <div align="center"> [Задача 1628. Белые полосы](https://acm.timus.ru/problem.aspx?space=1&num=1628) </div>

>Ограничение времени: 1.0 секунды
>Ограничение памяти: 64 МБ

###### Условие:

> У каждого неудачника в жизни бывают не только чёрные, но и белые полосы. Марсианин Вась-Вась отмечает в календаре, представляющем собой таблицу *m* × *n*, те дни, когда ему ужасно не повезло. Если Вась-Васю не повезло в *j*-й день *i*-й недели, то он закрашивает ячейку таблицы (*i*, *j*) в чёрный цвет. Все незакрашенные ячейки в таблице имеют белый цвет.
>
> Будем называть отрезками жизни прямоугольники размером 1 × *l* либо *l* × 1. Белыми полосами Вась-Вась считает все максимальные по включению белые отрезки таблицы. А сможете ли Вы определить, сколько всего белых полос было в жизни Вась-Вася?

###### Исходные данные:

> Первая строка содержит целые числа *m*, *n*, *k* — размеры календаря и количество неудачных дней в жизни Вась-Вася (1 ≤ *m*, *n* ≤ 30000; 0 ≤ *k* ≤ 60000). В следующих *k* строках перечислены неудачные дни в виде пар (*xi*, *yi*), где *xi* — номер недели, к которой относится неудачный день, а *yi* — номер дня в этой неделе (1 ≤ *xi* ≤ *m*; 1 ≤ *yi* ≤ *n*). Описание каждого неудачного дня встречается только один раз.

###### Результат:

> Выведите число белых полос в жизни Вась-Вася.

| Исходные данные          | Результат |
| ------------------------ | --------- |
| `3 5 4 1 1 1 5 2 2 3 3 ` | `8 `      |
| `5 1 2 2 1 3 1 `         | `2`       |

###### Интерпретация задачи:

>  Найти все существующие непрерывные полосы из одного и более элементов по вертикали и горизонтали, таким образом что либо ячейка принадлежит более протяженной полосе либо по одной координате (+1), либо по другой (+1), либо по обоим (+2), либо не принадлежит никому и считается отдельно (+1)

###### Описание алгоритма:

>  Создаем два динамических массива set-ов: х[m] в котором содержатся отсортированные координаты Y_cordinat соответствующие x[X_cordinat]  (ассоциация Y c X), и второй массив с точностью наоборот (ассоциация X c Y). Затем каждую строку обоих массивов проверяем на наличие белых полос, если их длинна больше 1 - сразу выводим результат, если равна 1, то заменяем проверенную строчку на список координат одиночек. Затем проверяем список одиночек в обоих обновленных массивах, и если одиночка является таковой в обоих массивах, то увеличиваем количество белых полос на 1, в противном случае игнорируем

###### Реализация:

```cpp
#include <iostream>
#include <set>
#include <vector>
using namespace std;

int result = 0;

set<int> count(const set<int>& collection, int max_size) {
    int prev = 0;
    set<int> single_elements; // контейнер с сортировкой одиночек
    for(int curr : collection){
        if (curr - prev > 2) result++; // Если как минимум два белых подряд res++
        else if (curr - prev == 2) single_elements.insert(curr - 1); // Иначе добавляем в массив пустышек
        prev = curr; // обновляем переменную
    }
    if (max_size - prev > 1) result++; // если последняя плохая стоит не крайней res++
    else if (max_size - prev == 1) single_elements.insert(max_size); // Если предпоследней, то добавляем одиночку
    return single_elements; // Теперь на выходе массив одиночек в конкретной строке/ряду
}

int main() {
    int m, n, k, x, y;
    cin >> m >> n >> k;
    vector<set<int>> badX(m); // Динамический массив плохих дней х с сортировкой
    vector<set<int>> badY(n); // Динамический массив плохих дней у с сортировкой
    while(k--){
        cin >> x >> y;
        badX[x - 1].insert(y); // Массив х -> у
        badY[y - 1].insert(x); // Массив y -> x
    }

    for(set<int>& badx : badX) badx = count(badx, n); // Подсчитываем количество полос по x
    for(set<int>& bady : badY) bady = count(bady, m); // Подсчитываем количество полос по у
    for (int i = 0; i < m; i++) for (int it : badX[i]) // Считаем клетки - одиночки
        if (badY[it - 1].find(i + 1) != badY[it - 1].end()) result++;
    
    cout << result << endl; // Выводим результат
    return 0;
}
```

###### Подтверждение выполнения:

![image-20220214014336926](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220214014336926.png)

###### Комментарий к программе:

>  Полноценный массив m*n реализовывать нет смысла, так как он не пройдет по памяти
>  Получилось реализовать программу более быстрым способом и по времени, и по памяти, и она даже прошла все тесты, но по факту оно пройти не должно было в связи с возможностью вылета при определенных вводдных, которые не тестируются. 
