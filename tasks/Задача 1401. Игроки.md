#### <div align="center"> [Задача 1401. Игроки](https://acm.timus.ru/problem.aspx?space=1&num=1401) </div>

>Ограничение времени: 2.0 секунды
>Ограничение памяти: 64 МБ

###### Условие:

> Известно, что господин Чичиков зарабатывал свой капитал и таким способом: он спорил со всякими недотёпами, что сможет доказать, что квадратную доску размера 512 × 512 нельзя замостить следующими фигурами:
>
> ```
> X      XX       X       XX 
> XX      X      XX        X
> ```
>
> и всегда выигрывал. Однако один из недотёп оказался не так уж глуп, и сказал, что сможет замостить такими фигурами доску размера 512 × 512 без правой верхней клетки. Чичиков, не подумав, ляпнул, что он вообще может любую доску размера 2^n × 2^n без одной произвольной клетки замостить такими фигурами. Слово за слово, они поспорили. Чичиков чувствует, что сам он не докажет свою правоту. Помогите же ему!

###### Исходные данные:

> В первой строке записано целое число *n* (1 ≤ *n* ≤ 9). Во второй строке через пробел даны два целых числа *x*, *y*: координаты «выколотой» клетки доски (1 ≤ *x*, *y* ≤ 2^n), *x* — номер строки, *y* — номер столбца. Левый верхний угол доски имеет координаты (1, 1).

###### Результат:

> Ваша программа должна выдать 2^n строчек по 2^n чисел в каждой строке. На месте выбитой клетки должно стоять число 0. На месте остальных клеток должны стоять числа от 1 до (2^2*n* − 1) / 3 — номер фигуры, закрывающей данную клетку. Разумеется, одинаковые номера должны образовывать фигуры. Если же такую доску нельзя покрыть фигурами, выведите «−1».

| Исходные данные | Результат                         |
| --------------- | --------------------------------- |
| `2 1 1 `        | `0 1 3 3 1 1 4 3 2 4 4 5 2 2 5 5` |

###### Интерпретация задачи:

>  Заполнить квадратное поле с колличеством клеток (2^2n)-1 фигурами заданной выше геометрии и вывести результат заполнения

###### Описание алгоритма:

>  Поле представляется в виде двумерного массива, в который записываются числа. Данное поле делится на 4 новых равных поля размером 2^n-1. На стыке тех полей, где не должно остаться пустоты размещается фигура. Далее эта операция продолжается до тех пор, пока размер квадратов не станет 2^n-(n-2). В конце выводится результат размещения

###### Реализация:

```cpp
#include <iostream>
#include <vector>
using namespace std;

void paint(vector<vector<int>> &table, int x, int y, int i, int j, int n) {
    static int c; c++;
    int voidPosX = x - j, voidPosY = y - i; // Положение пустоты
    n = n / 2; // Центральная позиция текущего стола
    int ax = i + n, ay = j + n; // Ближайшая к центру точка сектора "a"
    int bx = i + n - 1, by = j + n; // Ближайшая к центру точка сектора "b"
    int cx = i + n, cy = j + n - 1; // Ближайшая к центру точка сектора "c"
    int dx = i + n - 1, dy  = j + n - 1; // Ближайшая к центру точка сектора "d"

    if (voidPosX >= n and voidPosY >= n) { // Если пустота в секторе "a"
        table[bx][by] = c; // Строим точку фигуры в секторе "b"
        table[cx][cy] = c; // Строим точку фигуры в секторе "c"
        table[dx][dy] = c; // Строим точку фигуры в секторе "d"
        if (n > 1) { // Ограничение на размер квадрата более 2*2, рекурсивно идем дальше, используя
            paint(table, x, y, ax, ay, n); // a
            paint(table, by, bx, i,  by, n); // b
            paint(table, cy, cx, cx, j,  n); // c
            paint(table, dy, dx, i,  j,  n); // d
        }
    } else if (voidPosX >= n and voidPosY < n) { // Если пустота в секторе "b"
        table[ax][ay] = c; // Строим точку фигуры в секторе "a"
        table[cx][cy] = c; // Строим точку фигуры в секторе "c"
        table[dx][dy] = c; // Строим точку фигуры в секторе "d"
        if (n > 1) { // Ограничение на размер квадрата более 2*2
            paint(table, ay, ax, ax, ay, n); // a
            paint(table, x,  y,  i,  by, n); // b
            paint(table, cy, cx, cx, j,  n); // c
            paint(table, dy, dx, i,  j,  n); // d
        }
    } else if (voidPosX < n and voidPosY >= n) { // Если пустота в секторе "c"
        table[ax][ay] = c; // Строим точку фигуры в секторе "a"
        table[bx][by] = c; // Строим точку фигуры в секторе "b"
        table[dx][dy] = c; // Строим точку фигуры в секторе "d"
        if (n > 1) { // Ограничение на размер квадрата более 2*2
            paint(table, ay, ax, ax, ay, n); // a
            paint(table, by, bx, i,  by, n); // b
            paint(table, x,  y,  cx, j,  n); // c
            paint(table, dy, dx, i,  j,  n); // d
        }
    } else  if (voidPosX < n and voidPosY < n) { // Если пустота в секторе "d"
        table[ax][ay] = c; // Строим точку фигуры в секторе "a"
        table[bx][by] = c; // Строим точку фигуры в секторе "b"
        table[cx][cy] = c; // Строим точку фигуры в секторе "c"
        if (n > 1) { // Ограничение на размер квадрата более 2*2
            paint(table, ay, ax, ax, ay, n); // a
            paint(table, by, bx, i,  by, n); // b
            paint(table, cy, cx, cx, j,  n); // c
            paint(table,  x,  y, i,  j,  n); // d
        }
    }
    return;
}

int main() {
    int n, x, y; cin >> n >> y >> x; // Считываие переменных
    n = 1 << n; x--; y--;
    vector<vector<int>> table(n, (vector<int>(n))); // Массив ировой доски
    paint(table, x, y, 0, 0, n); // Рекурсивно заполняем массив фигурами
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) cout << table[i][j] << " "; // Вывод строчки
        cout << endl; // Следующая строчка
    }
    return 0;
}
```

###### Подтверждение выполнения:

![image-20220215201152371](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220215201152371.png)

###### Комментарий к программе:

>  Условие выполнится при любых входных данных, так что часть задания «Если же такую доску нельзя покрыть фигурами, выведите «−1»» не требует реализации
>  Клетка, уже занятая размещением предыдущей фигуры, считается локальной пустотой в новом квадрате, полученном делением 
