#### <div align="center"> [Задача 1160. Network](https://acm.timus.ru/problem.aspx?space=1&num=1160) </div>

>Ограничение времени: 1.0 секунды
>Ограничение памяти: 64 МБ

###### Условие:

> Эндрю работает системным администратором и планирует создать новую сеть в своей компании. В компании будет N концентраторов, они могут быть соединены друг с другом с помощью кабелей. Поскольку каждый сотрудник компании должен иметь доступ ко всей сети, каждый концентратор должен быть доступен по кабелям от любого другого концентратора (возможно, с некоторыми промежуточными концентраторами).
>
> Поскольку доступны кабели разных типов, а более короткие дешевле, необходимо составить такой план подключения концентратора, чтобы максимальная длина одного кабеля была минимальной. Существует еще одна проблема - не каждый концентратор может быть подключен к любому другому из-за проблем с совместимостью и ограничений геометрии здания. Конечно, Эндрю предоставит вам всю необходимую информацию о возможных подключениях к концентратору.
>
> Вы должны помочь Эндрю найти способ подключения концентраторов таким образом, чтобы все вышеперечисленные условия были выполнены.

###### Исходные данные:

> Первая строка содержит два целых числа: N - количество концентраторов в сети (2 ≤ N ≤ 1000) и M — количество возможных подключений к концентратору (1 ≤ M ≤ 15000). Все концентраторы пронумерованы от 1 до N. Следующие M строк содержат информацию о возможных соединениях - номера двух концентраторов, которые могут быть подключены, и длина кабеля, необходимая для их подключения. Длина - это целое положительное число, не превышающее 10^6. Для подключения двух концентраторов будет не более одного способа. Концентратор не может быть подключен к самому себе. Всегда будет по крайней мере один способ подключения всех концентраторов.

###### Результат:

> Сначала выведите максимальную длину одного кабеля в вашем плане подключения к концентратору (значение, которое вы должны свести к минимуму). Затем выведите свой план: сначала выведите P - количество используемых кабелей, затем выведите P пар целых чисел - количество концентраторов, подключенных соответствующим кабелем. Разделяйте числа пробелами и/или разрывами строк.

| Исходные данные                           | Результат             |
| ----------------------------------------- | --------------------- |
| `4 6 1 2 1 1 3 1 1 4 2 2 3 1 3 4 1 2 4 1` | `1 4 1 2 1 3 2 3 3 4` |

###### Интерпретация задачи:

>  Найти минимальной длинны ребер графа, соединяющих вершины графа без образования петель или замкнутых последовательностей (реализовать алгоритм поиска минимального остовного дерева)

###### Описание алгоритма:

>  Задача сводится к использованию алгоритма Краскала на графах. Хабы представлены как вершины графа, а провода – рёбра. При считывании все рёбра записываются в вектор и сортируются. После – рёбра добавляются в граф с присвоением каждой вершине номера, соответствующего номеру подграфа, не соединенного с другими подграфам. В случае объединения двух подграфов им присваивается наименьший из их номеров. Это продолжается до тех пор, пока все вершины графа не будут соединены, затем выводится результат и требуемые проводники.

###### Реализация:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct cable {
    int a, b, l;
};

bool compare(cable a, cable b) { // Компаратор для sort
    return a.l < b.l; // критерий - длинна
}

int main() {
    int n, m, a, b, l; // Переменные
    cin >> n >> m; // Считывание количества хабов и возможных подключений к ним
    vector<cable> connect; // Массив кабелей (хабА, хабБ, длинна)
    vector<int> used_hubs (n, -1); // Вспомогательный массив подключенных хабов
    vector<int> used_cables(m, 0); // Вспомогательный массив использованных кабелей
    for (int i = 0; i < m; ++i) { // Считываем все кабели в массив
        cin >> a >> b >> l;
        connect.push_back((cable){a - 1, b - 1, l});
    }
    sort(connect.begin(), connect.end(), compare); // Сортируем кабели по убыванию

    int netID = 0, max = 0, counter = 0;
    for (int i = 0; i < m; i++) { // Проходимся по списку всех возможных соединений
        int &A = used_hubs[connect[i].a]; // Псевдоним хаба на одном конце кабеля
        int &B = used_hubs[connect[i].b]; // На другом (читаемость кода++)

        if (A != -1 and A == B) continue; // Если хабы уже соеденены, то можем идти дальше так как короче уже не будет из-за сортировки

        else if(A == -1 and B == -1 ) { // Если оба хаба не подсоеденены - подсоеденяем
            ++netID; A = netID; B = A;
        } else if ((A != -1 and B == -1 ) or (A == -1 and B != -1 )) { // Если подсоенен только один хаб
            A = A + B + 1; B = A; // Подсоеденяем к уже имеющейся сети подключенного хаба
        } else { // Случай замкнутости графа - выбираем наименьший уровень из двух возможных
            int minID, maxID;
            if(B > A) {
                minID = A; maxID = B;
            } else {
                minID = B; maxID = A;
            }
            for (int j = 0; j < n; j++) if(used_hubs[j] == maxID) used_hubs[j] = minID;
        }
        used_cables[i] = 1;
        max = connect[i].l;
        ++counter;
    }
    cout << max << endl << counter << endl; // Выводим количество требуемых кабелей
    for (int j = 0; j < m; j++) if (used_cables[j])
            cout << connect[j].a + 1 << " " << connect[j].b + 1 << endl; // Печатаем все соединения
    return 0;
}
```

###### Подтверждение выполнения:

![image-20220215033507402](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220215033507402.png)

###### Комментарий к программе:

>  Перевод задачи может быть корявым
