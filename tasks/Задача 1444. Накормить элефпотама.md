#### <div align="center"> [Задача 1444. Накормить элефпотама](https://acm.timus.ru/problem.aspx?space=1&num=1444) </div>

>Ограничение времени: 0.5 секунды
>Ограничение памяти: 64 МБ

###### Условие:

> Гарри Поттер сдаёт экзамен по предмету «Уход за магическими существами». Его задание — накормить карликового элефпотама. Гарри помнит, что элефпотамы отличаются прямолинейностью и невозмутимостью. Они настолько прямолинейны, что ходят строго по прямой, и настолько невозмутимы, что заставить их идти можно, только если привлечь его внимание к чему-нибудь действительно вкусному. И главное, наткнувшись на цепочку своих собственных следов, элефпотам впадает в ступор и отказывается идти куда-либо. По словам Хагрида, элефпотамы обычно возвращаются домой, идя в обратную сторону по своим собственным следам. Поэтому они никогда не пересекают их, иначе могут заблудиться. Увидев свои следы, элефпотам детально вспоминает все свои перемещения от выхода из дома (поэтому-то они и ходят только по прямой и лишний раз не меняют направление — так легче запоминать). По этой информации элефпотам вычисляет, в какой стороне расположена его нора, после чего поворачивается и идет прямо к ней. Эти вычисления занимают у элефпотама некоторое (довольно большое) время. А то, что некоторые невежды принимают за ступор, на самом деле есть проявление выдающихся вычислительных способностей этого чудесного, хотя и медленно соображающего животного!
>
> Любимое лакомство элефпотамов — слоновьи тыквы, именно они и растут на лужайке, где Гарри должен сдавать экзамен. Перед началом испытания Хагрид притащит животное к одной из тыкв. Скормив элефпотаму очередную тыкву, Гарри может направить его в сторону любой оставшейся тыквы. Чтобы сдать экзамен, надо провести элефпотама по лужайке так, чтобы тот съел как можно больше тыкв до того, как наткнется на свои следы.

###### Исходные данные:

> В первой строке входа находится число *N* (3 ≤ *N* ≤ 30000) — количество тыкв на лужайке. Тыквы пронумерованы от 1 до *N*, причем номер один присвоен той тыкве, у которой будет стоять элефпотам в начале экзамена. В следующих *N* строках даны координаты всех тыкв по порядку. Все координаты — целые числа от −1000 до 1000. Известно, что положения всех тыкв различны, и не существует прямой, проходящей сразу через все тыквы.

###### Результат:

> В первой строке выхода вы должны вывести *K* — максимальное количество тыкв, которое может съесть элефпотам. Далее по одному числу в строке выведите *K* чисел — номера тыкв в порядке их обхода. Первым в этой последовательности всегда должно быть число 1.

| Исходные данные          | Результат   |
| ------------------------ | ----------- |
| `4 0 0 10 10 0 10 10 0 ` | `4 1 3 2 4` |

###### Интерпретация задачи:

>  Вывести такую последоватльность обхода точек на плоскости, что бы путь от одной точки до другой не пересекался с уже пройденными путями

###### Описание алгоритма:

>  Первая точка выбирается как начало координат. По ходу считывания записывается угол каждой точки относительно оси Ox и расстояние до нового начала координат. После этого точки сортируются по углу и по расстоянию от начала координат, таким образом итоговая геометрия обхода будет похожа на розу ветров. После сортировки находится максимальный угол между направлениями на две соседние точки, чтобы найти начало обхода, исключающее пересечение с маршрутом 2 соседних точек. После всех операций выводится обход точек с точки входа.

###### Реализация:

```cpp
#include <iostream>
#include <cmath>
using namespace std;
#define PI 3.14159265;

struct pumpkin {
    float length; // Расстояние от начала координат
    double degrees; // Угол от начала координат
    int index; // Индекс тыквы
    void create(int f_x, int f_y, int index) { // Рассчитываем все значения относительно начала координат
        int x, y; cin >> x >> y;
        this->index = index + 1; // Ставим индекс
        this->length = (x - f_x) * (x - f_x) + (y - f_y) * (y - f_y); // Славься, Пифагор
        this->degrees = atan2(y - f_y, x - f_x) * 180.0 / PI; // Рассчет угла
        if (y - f_y < 0) this->degrees += 360; // Делаем все углы положительными
    }
};

int compare_points(const void *var1, const void *var2) { // Компаратор для sort
    const pumpkin *p1 = (pumpkin*) var1;
    const pumpkin *p2 = (pumpkin*) var2;
    if (p1->degrees - p2->degrees > 1e-10) return 1; // Приритет у угла
    else if (p1->degrees - p2->degrees < -1e-10) return -1;
    else if (p1->length > p2->length) return 1; // Если углы ~похожи, то сравниваем координаты
    else return -1;
}

int main() {
    int n, f_x, f_y, x,y; // Переменные
    cin >> n >> f_x >> f_y; // Считываем количество тыкв и начальную точку
    pumpkin pumpkins[n]; // Массив тыкв
    pumpkins[0] = (pumpkin){0, -1,1}; // что бы небыло ошибок сортировки, тк
    for (int i = 1; i < n; i ++) pumpkins[i].create(f_x, f_y, i); // Заполняем массив тыкв

    qsort(pumpkins, n, sizeof(pumpkin), compare_points); // Сортируем вектора по углам и длинам

    int start_point = 1; // Стартовая точка изначально
    for (int i = 1; i < n - 1; i ++) // Если угол больше 180* будет пересечеение путей
        if (pumpkins[i + 1].degrees - pumpkins[i].degrees > 179.999) start_point = i+1;
    
    cout << n << endl << 1 << endl; // Выводим количество точек и первую точку (всегда 1)
    
    for (int i = start_point; i < n; i ++) cout << pumpkins[i].index << endl; // Организуем вывод значений по кругу
    for (int i = 1; i < start_point; i ++) cout << pumpkins[i].index << endl; // Относительно точки входа
    return 0;
}
```

###### Подтверждение выполнения:

![image-20220215171154324](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220215171154324.png)

###### Комментарий к программе:

> Так как все углы у нас в диапаоне от 0 до 360*, и отсортированны по возрастанию, то необходимо в качестве стартовой точки выбрать либо любую, либо ту, угол от которй до предидущей больше 180 при ее наличии, так как в противном случае может быть пеерсечение. Такая точка может быть всего одна
