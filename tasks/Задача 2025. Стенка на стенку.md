#### <div align="center"> [Задача 2025. Стенка на стенку](https://acm.timus.ru/problem.aspx?space=1&num=2025) </div>

>Ограничение времени: 1.0 секунды
>Ограничение памяти: 64 МБ

###### Условие:

> Бокс, каратэ, самбо… Классические боевые единоборства пресытили аудиторию. Поэтому известный спортивный канал запускает новый формат соревнований, основанный на традиционной русской забаве — боях стенка на стенку. В соревновании могут участвовать от двух до k команд, каждая из которых будет соперничать с остальными. Всего в соревновании примут участие n бойцов. Перед началом боя они должны разделиться на команды, каждый боец должен войти ровно в одну команду. За время боя два бойца сразятся, если они состоят в разных командах. Организаторы считают, что популярность соревнований будет тем выше, чем больше будет количество схваток между бойцами. Помогите распределить бойцов по командам так, чтобы максимизировать количество схваток между бойцами, и выведите это количество

###### Исходные данные:

> В первой строке дано количество тестов T (1 ≤ T ≤ 10). В следующих T строках перечислены тесты. В каждой из них записаны целые числа n и k через пробел (2 ≤ k ≤ n ≤ 10^4)

###### Результат:

> Для каждого теста в отдельной строке выведите одно целое число — ответ на задачу

| Исходные данные  | Результат |
| ---------------- | --------- |
| `3 6 3 5 5 4 2 ` | `12 10 4` |

###### Интерпретация задачи:

> Найти максимальное возможное количество взаимодействия каждого участника одной группы со всеми участниками всех остальных групп для всех групп

###### Описание алгоритма:

> Расспределяем участников по командам, если количество у частников не кратно количеству команд, то распределяем избыток участников по одному в уже существующую комманду. Затем рассчитывем количество возможных взаимодействий и выводим результат.

###### Реализация:

```cpp
#include <iostream>
using namespace std;

int main() {
    int t; // Количество испытаний
    int n; // Количество участников
    int k; // Количество комманд
    int minTeamSize; // Количествоучастников в самой маленькой комманде
    int numTeamsPlsOne; // Суммарный перевес участников отностиельно минимума
    cin >> t;
    for (int i = 0; i < t; i++) {
        int battles = 0;
        cin >> n >> k;
        minTeamSize = n / k; // Возвращает целочисленное деление
        numTeamsPlsOne = n % k; // Возвращает остаток
        for (;k>numTeamsPlsOne; k--) {
            n-=minTeamSize;
            battles += minTeamSize*n;
        } // Считаем количество комбинаций с маленькими командами
        for (; k>1; k--) {
            n-=minTeamSize+1;
            battles += (minTeamSize+1)*n;
        } // Досчитываем с большими 

        cout << battles << endl;
    }
    return 0;
}
```

###### Комментарий к программе:

> Метод перебора является самым простым и надежным (я не силен в комбинаторике), хоть и не самым быстрым
