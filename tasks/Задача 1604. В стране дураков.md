#### <div align="center"> [Задача 1604. В стране дураков](https://acm.timus.ru/problem.aspx?space=1&num=1604) </div>

>Ограничение времени: 1.0 секунды
>Ограничение памяти: 64 МБ

###### Условие:

> Главный бульдог-полицейский Страны Дураков решил ввести ограничение скоростного режима на автомобильной трассе, ведущей от Поля Чудес к пруду Черепахи Тортиллы. Для этого он заказал у Папы Карло *n* знаков ограничения скорости. Папа Карло слабо разбирался в дорожном движении и поэтому изготовил знаки с разными ограничениями на скорость: 49 км/ч, 34 км/ч, 42 км/ч, и т.д. Всего получилось *k* различных ограничений: *n*1 знаков с одним ограничением, *n*2 знаков со вторым ограничением, и т.д. (*n*1 + … + *nk* = *n*)
> Бульдог-полицейский ничуть не расстроился, получив такие знаки, напротив, он решил извлечь из этого экономическую выгоду. Дело в том, что по Правилам дорожного движения Страны Дураков ограничение на скорость действует вплоть до следующего знака. Если на знаке написано число 60, это означает, что участок от данного знака до следующего нужно проехать ровно со скоростью 60 километров в час — не больше и не меньше. Бульдог распорядился расставить знаки так, чтобы обогатившимся на Поле Чудес автолюбителям во время своего движения по трассе приходилось как можно больше раз менять скорость. Для этого нужно расставить имеющиеся знаки в правильном порядке. Если Вы поможете бульдогу это сделать, то он готов будет поделиться с Вами частью своих доходов.

###### Исходные данные:

> В первой строке дано число *k* — количество различных типов знаков с ограничением скорости (1 ≤ *k* ≤ 10000). Во второй строке через пробел перечислены целые положительные числа *n*1, …, *nk*. Сумма всех *ni* не превосходит 10000.

###### Результат:

> Выведите *n* целых чисел в пределах от 1 до *k* — порядок, в котором нужно расставить по трассе имеющиеся знаки. Вне зависимости от того, какой знак стоит первым, считается, что, проезжая его, водитель меняет скорость, так как до этого ограничения не действовали. Если задача имеет несколько решений, выведите любое.

| Исходные данные | Результат |
| --------------- | --------- |
| `2 2 2`         | `1 2 1 2` |

###### Интерпретация задачи:

>  Найти комбинацию из m значений по n1, n2, n3 ... nk дублей, такую что идет минимально-возможное количество повторений одного и того же знака подряд

###### Описание алгоритма:

>  В начале по очереди в массив записываются количество каждого из типов знаков, после чего происходит расстановка в цикле. Каждый следующий знак определяется как знак, количество которых максимально и тип следующего знака отличен от предыдущего. После установки знака, от убирается из массива (количество знаков этого типа уменьшается на 1)

###### Реализация:

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() { 
    short k, sum = 0, max_index = 0, last_index = 0; 
    cin >> k; // Считываем количество знак
    vector<short> flags(k); // Динамический массив знаков
    for (int i = 0; i < k; i++) { // Считывание значений в массив
        cin >> flags[i];
        sum += flags[i]; // Контрольная сумма
    }
    while (sum) { 
        max_index = 0;
        if (last_index == 0) max_index = 1; // Костыль
        for (int j = 0; j < k; j++)
            if(last_index != j && flags[j] >= flags[max_index])
            max_index = j; // Находим новый индекс с максимальным значением
            
        if (flags[max_index] == 0) max_index = last_index; // Если тут пусто, идем по новой
        flags[max_index] -= 1; // Убираем использованный знак
        last_index = max_index; // Исключаем повторения
        cout << max_index + 1 << ' '; // Выводим результат
        sum--; // Для выхода из цикла
    }
    return 0;
}
```

###### Подтверждение выполнения:

![image-20220214045202699](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220214045202699.png)

###### Комментарий к программе:

>  Врядли задача решена самым оптимальным способом, однако все тесты успешно пройдены
