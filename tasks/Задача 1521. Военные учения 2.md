#### <div align="center"> [Задача 1521. Военные учения 2](https://acm.timus.ru/problem.aspx?space=1&num=1521) </div>

>Ограничение времени: 1.0 секунды
>Ограничение памяти: 64 МБ

###### Условие:

> В ходе недавних военных учений министр обороны Советской Федерации товарищ Иванов имел возможность лично убедиться в блестящей боевой готовности солдат вверенной ему Советской Армии. Но одна вещь всё же продолжала беспокоить выдающегося военачальника. Прославленный генерал понимал, что была продемонстрирована лишь физическая подготовка солдат. Теперь настало время организовать очередные учения и проверить интеллектуальные способности личного состава.
>
> Генерал Шульман, вновь назначенный ответственным за проведение учений, пожертвовал все выделенные деньги бедным и с чистой совестью лёг спать. Во сне генералу явился учебник по тактике и изложил схему, руководствуясь которой можно провести учения совершенно бесплатно.
>
> В соответствии с этой схемой учения делятся на **N** раундов, в течение которых **N** солдат, последовательно пронумерованных от 1 до **N**, маршируют друг за другом по кругу, т.е. первый следует за вторым, второй за третьим, ..., (**N**-1)-й за **N**-м, а **N**-й за первым. В каждом раунде очередной солдат выбывает из круга и идёт чистить унитазы, а оставшиеся продолжают маршировать. В очередном раунде выбывает солдат, марширующий на **K** позиций впереди выбывшего на предыдущем раунде. В первом раунде выбывает солдат с номером **K**.
>
> Разумеется, г-н Шульман не питал никаких надежд на то, что солдаты в состоянии сами определить очерёдность выбывания из круга. «Эти неучи даже траву не могут ровно покрасить», – фыркнул он и отправился за помощью к прапорщику Шкурко.

###### Исходные данные:

> Единственная строка содержит целые числа **N** (1 ≤ **N** ≤ 100000) и **K** (1 ≤ **K** ≤ **N**).

###### Результат:

> Вывести через пробел номера солдат в порядке их выбывания из круга.

| Исходные данные | Результат   |
| --------------- | ----------- |
| `5 3 `          | `3 1 5 2 4` |

###### Интерпретация задачи:

>  В замкнутом массиве находятся элементы с номерами. Отсчет идет от 1го элемента. Каждый k-тый элемент удоляется, скоращая размер массива на 1. Так повторяется до тех пор, пока не останется ни одного элемента.

###### Описание алгоритма:

>  Создаётся вектор с номерами всех «солдат» начиная с 1, а в затем в цикле из вектора удоляется и выводится аждый выбывший. При этом идет сокращение размера массива на 1 в каждой итерации. В конечной итерации для исключения zero division последний (i=0) элемент массива выводится отдельно

###### Реализация:

```cpp
#include <stdio.h>
#include <vector>
using namespace std;

int main() {
    int n, k, turn; scanf("%d %d",&n,&k); // Считывание переменных
    vector<int> squad; // Динамический массив 
    for (int i = 1; i < n+1; i++) squad.push_back(i); // Заполнение массива
    k--; turn = k; // Значение хода уменьшаем на 1 что бы корректно отрабатывать цикл
    for (--n; n > 0; n--) {
        printf("%d ", squad[turn]); // Выводим того, кто выбыл на прошлой итерации
        squad.erase(squad.begin() + turn); // удаляем выбывшего
        turn = (turn + k) % (n); // Выбираем нового выбывшего
    }
    printf("%d ",squad[0]); // Последний выбывший отдельно ибо zero division
    return 0; 
}
```

###### Подтверждение выполнения:

![image-20220214155302108](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220214155302108.png)

###### Комментарий к программе:

>  Попытка использовать iostream оказалась провальной по времени. Текущее решение проходит тесты по времени, но на пределе. Возможно решение через node будет быстрее, но при этом более сложное в реализации
