#### <div align="center"> [Задача 1494. Монобильярд](https://acm.timus.ru/problem.aspx?space=1&num=1494) </div>

>Ограничение времени: 1.0 секунды
>Ограничение памяти: 64 МБ

###### Условие:

> Стол для монобильярда, установленный в игровом доме уездного города N, оказался очень прибыльным вложением. До того, как в городе появился небезызвестный господин Чичиков. Раз за разом он выигрывал, и хозяин, подсчитывая убытки, понимал, что дело тут нечисто. Однако уличить подлеца в жульничестве не удавалось до прибытия в город N ревизора из Петербурга.
>
> Правила игры в монобильярд очень просты: нужно последовательно закатить в единственную лузу шары с номерами 1, 2, …, *N* (именно в этом порядке). Пока господин Чичиков играл, ревизор несколько раз подходил к столу и забирал из лузы последний закатившийся туда шар. В конце концов, оказалось, что Чичиков закатил в лузу все шары, а ревизор все шары достал и обследовал. Аферист утверждал, что закатил шары в правильном порядке. Хозяин понял, что это его шанс: ревизор должен помнить, в каком порядке он доставал шары. Однако так ли легко будет доказать жульничество?

###### Исходные данные:

> В первой строке записано целое число *N* — количество бильярдных шаров (1 ≤ *N* ≤ 100000). В следующих *N* строках даны номера этих шаров в том порядке, в котором ревизор забирал их из лузы.

###### Результат:

> Выведите слово «Cheater», если Чичиков не мог закатить все *N* шаров в правильном порядке. Иначе выведите «Not a proof».

| Исходные данные | Результат      |
| --------------- | -------------- |
| `2 2 1 `        | `Not a proof ` |
| `3 3 1 2 `      | `Cheater`      |

###### Интерпретация задачи:

>  Смотреть последовательность на прерывания с откатом значения назад более чем на 1 за 1 взятый шар. Сохрнить шары, взятые за k итераций, рассмотрть разные случаи последовательности и в случае нарушения закономерности вывести вердикт о жульничестве

###### Описание алгоритма:

>  Игроку нужно забивать шары строго в порядке возрастания номеров. Значит, ревизору нужно доставать их строго в обратном порядке, чтобы подтвердить честность игрока. При этом, супервизор может подойти в любой момент времени. Первый шар x[i] означает, что забиты шары от 0 до i. Пусть следующий шар x[j], есть 3 варианта развития событий:
>  Если j - i > 1, то были забиты все шары от i до k
>  Если j - i = 1, то за время отсутствия супервизора небыло забито мячей
>  Если (j - k) =< 0, то за время отсутствия супервизора или был забит шар с меньшим номером, или не не был забит, но порядок был нарушен ранее -> вывод о жульничетве

###### Реализация:

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n, currentBall, max = 0; 
    cin >> n;
    vector<int> balls(n); // Динамический массив взятых шаров
    for (int i = 0; i < n; i++) { // Цикл считывания и проверки
        cin >> currentBall; // Считывание и запись шара в буфер
        if (currentBall > max) { // Добавляем в массив все элементы, которые скорее всего уже были
            for (int j = max + 1; j <= currentBall - 1; j++) balls.push_back(j);
            max = currentBall;
        } else if (currentBall == balls.back()) balls.pop_back(); // Убираем последний элемент (так как мы его взяли)
        else { // Жулик если текущий мяч меньше последнего
                cout << "Cheater" << endl;
                return 0;
        }
    }
    cout << "Not a proof" << endl;
    return 0;
}
```

###### Подтверждение выполнения:

![image-20220213170906874](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220213170906874.png)

###### Комментарий к программе:

>  Возможно существует алгоритм, который не требовал бы в крайнем случае массива размером ~100000, однако даже текущий вариант проходит по памяти
