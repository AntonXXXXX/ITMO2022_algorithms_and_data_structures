#### <div align="center"> [Задача 1080. Раскраска карты](https://acm.timus.ru/problem.aspx?space=1&num=1080) </div>

>Ограничение времени: 1.0 секунды
>Ограничение памяти: 64 МБ

###### Условие:

> Рассмотрим географическую карту с *N* странами, занумерованными от 1 до *N* (0 < *N* < 99). Для каждой страны известны номера соседних стран, т.е. имеющих общую границу с данной. Из каждой страны можно попасть в любую другую, перейдя некоторое количество границ. Напишите программу, которая определит, возможно ли покрасить карту только в два цвета — красный и синий — так, что если две страны имеют общую границу, их цвета различаются. Цвет первой страны — красный. Ваша программа должна вывести одну возможную раскраску для остальных стран или сообщить, что такая раскраска невозможна.

###### Исходные данные:

> В первой строке записано число *N*. Из следующих *N* строк *i*-я строка содержит номера стран, с которыми *i*-я страна имеет границу. Каждое целое число в *i*-й строке больше, чем *i*, кроме последнего, которое равно 0 и обозначает конец списка соседей *i*-й страны. Если строка содержит 0, это значит, что *i*-я страна не соединена ни с одной страной с б*o*льшим номером.

###### Результат:

> Вывод содержит ровно одну строку. Если раскраска возможна, эта строка должна содержать список нулей и единиц без разделителей между ними. *i*-я цифра в этой последовательности обозначает цвет *i*-й страны. 0 соответствует красному цвету, единица — синему. Если раскраска невозможна, выведите целое число –1.

| Исходные данные | Результат |
| --------------- | --------- |
| `3 2 0 3 0 0 `  | `010`     |

###### Интерпретация задачи:

>  Необходимо реализовать алгоритм раскраски графа в 2 цвета так, чтобы смежные вершины не могли быть раскрашены в один цвет

###### Описание алгоритма:

>  Создадим структуру данных , которая будет содержать данные о своём цвете и номера стран, с которыми имеет границы. Так как на вход алгоритм получает лишь частично заполненный граф, нам требуется сделать его полностью заполненным (что бы у каждой страны был список стран с которыми она граничит). Затем, используя граф и номер стартовой вершины, на каждом шаге красим одну вершину в определённый цвет в зависимости от того, какого цвета была предыдущая вершина. Если рядом две вершины одного цвета, то выходим из программы выводя -1, иначе выводим последовательность цветов.

###### Реализация:

```cpp
#include <vector>
#include <queue>
#include <iostream>
using namespace std;

struct Country { // Структура страны, содержашая цвет и соседей
    int color = -1; // -1 - не посещен, 0 - красный, 1 - синий
    vector<int> borders; // Динамический массив иначе жирно по памяти
};

int main() {
    int n;
    cin >> n; // Считывание количества стран
    vector<Country> countries(n + 1); // Что бы нумерация стран шла от 1 а не от 0
    int countryID;
    for (int i = 1; i <= n; i++) {
        cin >> countryID; // Считываем первую страну
        while (countryID != 0) { // Создаем полный список границ каждой страны
            countries[i].borders.push_back(countryID); // Дополняем список границ i-той страны
            countries[countryID].borders.push_back(i); // Дополняем список границ предидущих стран, с которой данная страна имеет границы, данной страной
            cin >> countryID;
        }
    }
    for (int cID = 1; cID <= n; cID++) { // Для всех стран прогоняем раскраску
        if (countries[cID].color == -1) { // Если для текущей страны не выставлен цвет
            queue<int> q; 
            q.push(cID);
            countries[cID].color = 0;
            while (!q.empty()) { // Пока у нас в очереди есть хотя бы один элемент
                int first = q.front(); q.pop(); // Забираем первый элемент очереди
                for (int cID = 0; cID < countries[first].borders.size(); cID++) { // Проверяем, есть ли у страны граница со страной с таким же цветом
                    int neighbour = countries[first].borders[cID];
                    if (countries[first].color == countries[neighbour].color) { // Если соседние страны одного цвета
                        cout << "-1"; // выводим -1
                        exit(0); // Дальше нам всё-равно
                    }
                    if (countries[neighbour].color == -1) { // Если нет
                        countries[neighbour].color = (countries[first].color == 0 ? 1 : 0); // То раскрашиваем в цвет, отличный от цвета текущей страны
                        q.push(neighbour); // Добавляем в очередь страну для проверки
                    }
                }
            }
        }
    }
    for (int i = 1; i <= n; i++) cout << countries[i].color; // Выводим цвет
    return 0;
}
```

###### Подтверждение выполнения:

![image-20220213031923917](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220213031923917.png)

###### Комментарий к программе:

>  Можно было бы сделать массив со списком уже раскрашенных стран, это было бы проще, но в отличии от варианта с 3-мя состояниями цвета этот вариант более медленный. Однако требуется более одного прохода для исключения ошибок на несвязанном графе.