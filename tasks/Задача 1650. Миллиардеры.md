#### <div align="center"> [Задача 1650. Миллиардеры](https://acm.timus.ru/problem.aspx?space=1&num=1650) </div>

>Ограничение времени: 3.0 секунды
>Ограничение памяти: 64 МБ

###### Условие:

> Возможно, вы знаете, что из всех городов мира больше всего миллиардеров живёт в Москве. Но, поскольку работа миллиардера подразумевает частые перемещения по всему свету, в определённые дни какой-то другой город может занимать первую строчку в таком рейтинге. Ваши приятели из ФСБ, ФБР, MI5 и Шин Бет скинули вам списки перемещений всех миллиардеров за последнее время. Ваш работодатель просит посчитать, сколько дней в течение этого периода каждый из городов мира был первым по общей сумме денег миллиардеров, находящихся в нём.

###### Исходные данные:

> В первой строке записано число *n* — количество миллиардеров (1 ≤ *n* ≤ 10000). Каждая из следующих *n* строк содержит данные на определённого человека: его имя, название города, где он находился в первый день данного периода, и размер состояния. В следующей строке записаны два числа: *m* — количество дней, о которых есть данные (1 ≤ *m* ≤ 50000), *k* — количество зарегистрированных перемещений миллиардеров (0 ≤ *k* ≤ 50000). Следующие *k* строк содержат список перемещений в формате: номер дня (от 1 до *m* − 1), имя человека, название города назначения. Вы можете считать, что миллиардеры путешествуют не чаще одного раза в день, и что они отбывают поздно вечером и прибывают в город назначения рано утром следующего дня. Список упорядочен по возрастанию номера дня. Все имена и названия городов состоят не более чем из 20 латинских букв, регистр букв имеет значение. Состояния миллиардеров лежат в пределах от 1 до 100 миллиардов.

###### Результат:

> В каждой строке должно содержаться название города и, через пробел, количество дней, в течение которых этот город лидировал по общему состоянию миллиардеров, находящихся в нём. Если таких дней не было, пропустите этот город. Города должны быть отсортированы по алфавиту (используйте обычный порядок символов: ABC...Zabc...z).

| Исходные данные                                              | Результат                   |
| ------------------------------------------------------------ | --------------------------- |
| 5 Abramovich London 15000000000 Deripaska Moscow 10000000000 Potanin Moscow 5000000000 Berezovsky London 2500000000 Khodorkovsky Chita 1000000000 25 9 1 Abramovich Anadyr 5 Potanin Courchevel 10 Abramovich Moscow 11 Abramovich London 11 Deripaska StPetersburg 15 Potanin Norilsk 20 Berezovsky Tbilisi 21 Potanin StPetersburg 22 Berezovsky London | Anadyr 5 London 14 Moscow 1 |

###### Интерпретация задачи:

>  Подсчитать количество дней, в течении которых суммарное состояние миллиардеров, находящихся в городе, было больше, чем в каком либо городе еще в этот день, и вывести результат.

###### Описание алгоритма:

>  Так же как и входные данные, алгоритм можно разделить на две части. Первая - грамотное формирование всех необходимых структур и массивов данных, затем заполнние их части теми данными, которые получены в первой части программы
>  Вторая часть - последовательное считывание дорожной карты миллиардеров и их пребрасывание из одного города в другой, с соответсвующим обновлением рейтинга городов по капиталу в силу его изменения из за перемещения миллиардера.
>  Затем достаточно просто пройтись по всем городам из топа, отсортировать их в алфавитном порядке и вывести результат

###### Реализация:

```cpp
#include <string>
#include <set>
#include <map>
#include <unordered_map>
#include <iostream>
#include <functional> // Для сортировки в set
using namespace std;

struct City { // Город - деньги - дни
    string name; // Название города
    long long money{}; // Количество денег
    int days{}; // Количество дней в топе
};

struct Person { // Деньги - город
    City* city; // Город
    long long money; // Деньги
};

int main()
{
    City cities[60000]; // Массив городов
    Person persons[10000]; // Массив персон
    unordered_map<string, Person*> name_person; // Мапа имя - персона
    map<string, City*> name_city; // Мапа название - город
    set<pair<long long, City*>, greater<>> top_city; // Сортировка городов по сумме денег

    int n, m, k, count = 0; cin >> n; // Переменные
    string person_n, city_n; long long money; // Переменные
    for(int i = 0; i < n; i++) { // Цикл считывания имен миллиардеров, городов и состояний в 0 день
        cin >> person_n >> city_n >> money; // Считывание переменных
        name_person[person_n] = &persons[i]; // Добавляем персону
        if(!name_city[city_n]) name_city[city_n] = &cities[count++]; // Если еще нет такого города добавляем
        persons[i] = (Person){name_city[city_n], money}; // Заполняем карточку персоны
        name_city[city_n]->name = city_n; // Добавляем название города
        name_city[city_n]->money += money; // Суммируем капитал
    }
    for(const auto& nameCity : name_city) // Добавляем города в список лучших
        top_city.insert({nameCity.second->money, nameCity.second });

    int prevday = 0, day; string name, place; cin >> m >> k; // Переменные
    while(true) {
        bool finished = (!(cin >> day >> person_n >> place)); // Пока есть что считывать идем дальше
        if(finished) day = m; // Для предотвращения выхода из цикла раньше времени

        if(day != prevday) { // Если день идет дальше
            auto it2 = top_city.begin(); // Первый город в списке по сумме на данный момент
            auto it = it2++; // Второй город в списке (на случай если совпадают суммы)
            if(it2 == top_city.end() or it->first > it2->first) // Если только один день или первый день превосходит второй
                it->second->days += day-prevday; // Увеличиваем количество дней топового города на разницу во времени
        }
        if(finished) break; // Выходим, если городов больше нет
        if(!name_city[place]) { // Если такого города еще небыло
            name_city[place] = &cities[count++]; // Добавляем его
            name_city[place]->name = place;
        }

        { // Обновление набора и сруктуру данных
            auto nextplace = name_city[place]; // Псевдоним города
            auto person = name_person[person_n]; // Псевдоним персоны
            auto prevplace = person->city; // Псевдоним положения персоны
            auto prevmoney = prevplace->money; // Псевдоним денег города
            { // Перекидываем персону из одного города в другой
                top_city.erase({prevmoney, prevplace}); // удаляем из старого
                prevplace->money -= person->money; // уменьшаем капитал города
                top_city.insert({prevplace->money, prevplace}); // добавляем в новый город
                top_city.erase({nextplace->money, nextplace}); // удаляем старый топовый город
                nextplace->money += person->money; // пересчитваем капитал нового города
                top_city.insert({nextplace->money, nextplace}); // корректируем капитал нового города
                person->city = nextplace; // меняем текущую локацию персоны
                prevday = day; // Идем на следующую итерацию
            }
        }
    }
    map<string, int> output; // Вывод с сортировкой по алфавиту
    for(auto& r : top_city) if(r.second->days) // Если был в топе хоть раз
        output.insert(make_pair(r.second->name, r.second->days)); // Добавляем к выводу
    for(auto& o : output) cout << o.first << " " << o.second << "\n"; // Выводим
}
```

###### Подтверждение выполнения:

![image-20220216215344849](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220216215344849.png)

###### Комментарий к программе:

>  Оказывается, состояние миллиардера не обязательно кратно 10^9.
>  Основная сложность задачи - манипуляция большим количеством видов данных и поддержка связи между ними.
